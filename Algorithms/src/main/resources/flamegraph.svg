<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" width="1200.000000" height="268.000000" onload="init(evt)" viewBox="0 0 1200.000000 268.000000" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<defs>
    <linearGradient id="background" y1="0" y2="1" x1="0" x2="0" >
        <stop stop-color="#eeeeee" offset="5%" />
        <stop stop-color="#eeeeb0" offset="95%" />
    </linearGradient>
</defs>
<style type="text/css">
.func_g:hover { stroke:black; stroke-width:0.5; cursor:pointer; }.func_h:hover { stroke:black; stroke-width:0.5; cursor:pointer; }</style>
<script type="text/ecmascript">
<![CDATA[
/*
 * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

// highlighting and info text

function s(node) {        // show
    let sample = null;
    if (node.getAttribute("class") == "func_g") {
        sample = sample_for_id(node.getAttribute("id").substring(2));
    } else if (node.getAttribute("class") == "func_h") {
        sample = histogram_entry_for_id(node.getAttribute("id").substring(2));
    }
    let name = name_for_sample(sample)
    let details = name + " (" + languageNames[sample.l] + ") - ";
    if (sample.hasOwnProperty("h")) {
        if (fg_collapsed) {
            details = details + "(Self:" + (sample.ri + sample.rc) + " samples " +
                "Total: " + (sample.rh) + " samples)";
        } else {
            details = details + "(Self:" + (sample.i + sample.c) + " samples " +
                "Total: " + (sample.h) + " samples)";
        }
    } else {
        details = details + "(" + (sample.i + sample.c) + " samples)";
    }

    flamegraph_details.textContent = details;
}

function c(node) {            // clear
    flamegraph_details.nodeValue = ' ';
}

// Utility function

function child(parent, name) {
    for (let i=0; i<parent.children.length;i++) {
        if (parent.children[i].tagName == name)
            return parent.children[i];
    }
    return;
}

function save_attr(e, attr, val) {
    if (e.hasAttribute("_orig_"+attr)) return;
    if (!e.hasAttribute(attr)) return;
    e.setAttribute("_orig_"+attr, val != undefined ? val : e.getAttribute(attr));
}

function restore_attr(e, attr) {
    if (!e.hasAttribute("_orig_"+attr)) return;
    e.setAttribute(attr, e.getAttribute("_orig_"+attr));
    e.removeAttribute("_orig_"+attr);
}

function find_sample_in_tree(id, parents, unrelated) {
    let result = profileData[id];
    let sample = result;
    let parent = sample.p
    while (parent != null) {
        parents.push(profileData[parent]);
        for (const sibling of profileData[parent].s) {
            if (sibling != sample.id) {
                unrelated.push(profileData[sibling]);
            }
        }
        sample = profileData[parent];
        parent = sample.p;
    }
    return result;
}

function validate_no_overlap(sample, parents, unrelated) {
    let ary = [];
    for (const p of parents) {
        ary[p.id] = 1;
    }

    let iter = sample_and_children_depth_first(sample);
    let c = iter.next();
    while (!c.done) {
        if (ary[c.value.id] == undefined) {
            ary[c.value.id] = 1;
        } else {
            ary[c.value.id] = ary[c.value.id] + 1;
        }
        c = iter.next();
    }

    for (const u of unrelated) {
        iter = sample_and_children_depth_first(u);
        c = iter.next();
        while (!c.done) {
            if (ary[c.value.id] == undefined) {
                ary[c.value.id] = 1;
            } else {
                ary[c.value.id] = ary[c.value.id] + 1;
            }
            c = iter.next();
        }
    }

    let problems = 0;
    for (let i = 0; i < ary.length; i++) {
        if (ary[i] != 1) {
            console.log("Unexpected value of " + ary[i] + " for " + i + ".")
            problems++;
        }
    }

    if (problems > 0) {
        console.log("Problems found for sample " + sample.id + ".");
    }
}

function sample_parents_and_unrelated_for_id(id) {
    let parents = [];
    let unrelated = [];
    let result =  [find_sample_in_tree(id, parents, unrelated), parents, unrelated];
    return result
}

function sample_for_id(id) {
    return profileData[id];
}

function depth_for_sample(sample) {
    if (!sample.hasOwnProperty("depth")) {
        let parent = profileData[sample.p];
        let depth = 0;
        while (parent != null) {
            if (parent.hasOwnProperty("depth")) {
                depth += parent.depth + 1;
                break;
            } else {
                depth += 1;
            }
            parent = profileData[sample.p];
        }
        sample.depth = depth;
    }
    return sample.depth;
}

function collapsed_depth_for_sample(sample) {
    if (!sample.hasOwnProperty("rdepth")) {
        let parent = profileData[sample.rp];
        let depth = 0;
        while (parent != null) {
            if (parent.hasOwnProperty("rdepth")) {
                depth += parent.rdepth + 1;
                break;
            } else {
                depth += 1;
            }
            parent = profileData[sample.rp];
        }
        sample.rdepth = depth;
    }
    return sample.rdepth;
}

function sample_and_children_depth_first(sample) {
    let stack = [sample];
    return {
        next: function() {
            if (stack.length == 0) {
                return {value: null, done: true}
            } else {
                let result = stack.pop();

                let rdepth = depth_for_sample(result);
                for(const child of direct_children(result).reverse()) {
                    if (!child.hasOwnProperty("depth")) {
                        child.depth = rdepth + 1;
                    }
                    stack.push(child);
                }
                return {value: result, done: false}
            }
        }
    }
}

function collapsed_sample_and_children_depth_first(sample) {
    let stack = [sample];
    return {
        next: function() {
            if (stack.length == 0) {
                return {value: null, done: true}
            } else {
                let result = stack.pop();

                let rdepth = depth_for_sample(result);
                for(const child of collapsed_children(result).reverse()) {
                    if (!child.hasOwnProperty("depth")) {
                        child.depth = rdepth + 1;
                    }
                    stack.push(child);
                }
                return {value: result, done: false}
            }
        }
    }
}

function direct_children(sample) {
    let result = [];
    if (sample.hasOwnProperty("s")) {
        for (const childId of sample["s"]) {
            let child = sample_for_id(childId);
            result.push(child);
        }
    }
    return result;
}

function collapsed_children(sample) {
    let result = [];
    if (sample.hasOwnProperty("rs")) {
        for (const childId of sample["rs"]) {
            let child = sample_for_id(childId);
            result.push(child);
        }
    }
    return result;
}

function title(e) {
    if (e.getAttribute("class") == "func_g") {
        return name_for_sample(sample_for_id(e.getAttribute("id").substring(2)));
    } else if (e.getAttribute("class") == "func_h") {
        return name_for_sample(histogram_entry_for_id(e.getAttribute("id").substring(2)));
    } else {
        return "";
    }
}

function key_for_sample(sample) {
    return sample.k;
}

function name_for_sample(sample) {
    let key = sampleKeys[sample.k];
    return profileNames[key[0]];
}

function source_for_sample(sample) {
    let key = sampleKeys[sample.k];
    return sourceNames[key[1]];
}

function source_line_for_sample(sample) {
    let key = sampleKeys[sample.k];
    return key[2];
}

function function_name(e) {
    return title(e);
}

function update_text(e) {
    var r = child(e, "rect");
    var t = child(e, "text");
    var w = parseFloat(r.attributes["width"].value) -3;
    var txt = function_name(e);
    t.setAttribute("x", parseFloat(r.getAttribute("x")) +3);

    update_text_parts(e, r, t, w, txt);
}

function update_text_parts(e, r, t, w, txt) {
    // Smaller than this size won't fit anything
    if (w < 2*fontSize*fontWidth) {
        t.style["display"] = "none";
        return;
    }

    let lengths = get_txt_lengths(txt);

    // Fit in full text width
    if (/^ *$/.test(txt) || substring_width(t, txt, txt.length, lengths) < w) {
        t.textContent = txt;
        t.style["display"] = "block";
        return;
    }

    let x = search_text_width(w, t, txt, lengths);

    if (x > 2) {
        t.style["display"] = "block";
        t.textContent = txt.substring(0,x - 2) + "..";
    } else {
        t.style["display"] = "none";
    }
}

function search_text_width(w, t, txt, lengths) {
    let x = Math.round(txt.length / 4);
    let good_x = 0;
    let bad_x = txt.length;

    while (x != good_x) {
        let w2 = substring_width(t, txt, x, lengths);
        if (w2 > w) {
            bad_x = x;
        } else {
            good_x = x;
        }
        x = Math.round((bad_x - good_x) / 4) + good_x;
    }
    return x;
}

var txt_length_cache = {}

function get_txt_lengths(txt) {
    let lengths = txt_length_cache[txt]
    if (lengths == undefined) {
        lengths = new Array(txt.length);
        lengths.fill(-1);
        txt_length_cache[txt] = lengths;
    }
    return lengths;
}

function substring_width(t, txt, x, lengths) {
    let w = lengths[x - 1];
    if (w == -1) {
        t.style["display"] = "block";
        if (t.textContent.length < (x + 2)) {
            t.textContent = txt.substring(0, x + 1);
        }
        w = t.getSubStringLength(0, x);
        lengths[x - 1] = w;
    }
    return w;
}

function owner_resize(new_width) {
    document.firstElementChild.width.baseVal.value = new_width;
    document.firstElementChild.viewBox.baseVal.width = new_width;

    let help = document.getElementById("help");
    if (help != null) {
        help.parentElement.x.baseVal.value = new_width - help.firstElementChild.width.baseVal.value - xpad
    }
}

var help_strings = [];

function graph_help_entry(e, i, key, description) {
    let y = (fg_frameheight * 2) + (i + 1) * fg_frameheight * 1.5;

    let box = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    box.x.baseVal.value = xpad;
    box.y.baseVal.value = y;
    box.width.baseVal.value = fg_frameheight * 2;
    box.height.baseVal.value = fg_frameheight;
    box.style.fill = "white";
    box.style.stroke = "black";
    box.style["stroke-width"] = 0.5;
    box.rx.baseVal.value = 2;
    box.ry.baseVal.vlaue = 2;

    let label = document.createElementNS("http://www.w3.org/2000/svg", "text");
    label.style.textAnchor = "middle";
    label.setAttribute("x", xpad + fg_frameheight);
    label.setAttribute("y", y - 5 + fg_frameheight);
    label.style.fontSize = fontSize;
    label.style.fontFamily = "Verdana";
    label.style.fill = "rgb(0, 0, 0)";
    label.textContent = key;

    let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.className.baseVal = "label";
    text.style.textAnchor = "left";
    text.setAttribute("x", xpad + fg_frameheight * 3);
    text.setAttribute("y", y - 5 + fg_frameheight);
    text.style.fontSize = fontSize;
    text.style.fontFamily = "Verdana";
    text.style.fill = "rgb(0, 0, 0)";
    text.textContent = description;

    e.appendChild(box);
    e.appendChild(label);
    e.appendChild(text);
}

function graph_popup_fix_width(e, right_justify) {
    let labels = e.getElementsByClassName("label");
    let max_label_end = 250;
    for (const label of labels) {
        let label_end = label.x.baseVal[0].value + label.getSubStringLength(0, label.textContent.length) + xpad;
        if (label_end > max_label_end) {
            max_label_end = label_end;
        }
    }
    let titles = e.getElementsByClassName("title");
    for (const title of titles) {
        title.x.baseVal.value = max_label_end / 2;
    }
    let popup = e.getElementsByClassName("popup")[0];
    popup.width.baseVal.value = max_label_end;
    if (right_justify) {
        e.parentElement.x.baseVal.value = fg_width - max_label_end - xpad;
    }
    graph_ensure_space();
};

function graph_register_handler(key, description, action) {
    window.addEventListener("keydown", function (e) {
        if (e.key == key && !e.isComposing && !e.altKey && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            action();
        }
    });
    help_strings.push([key, description]);
}

function graph_ensure_space() {
    let svg = document.firstElementChild;
    let maxY = 0;
    for (const e of svg.getElementsByTagName("svg")) {
        if (svg.style["display"] != "none") {
            let y = e.y.baseVal.value + e.height.baseVal.value;
            if (y > maxY) {
                maxY = y;
            }
        }
    }
    svg.height.baseVal.value = maxY;
    svg.viewBox.baseVal.height = maxY;
}
'use strict';
var fontSize = 12.0;
var fontWidth = 0.5;
var profileNames = ["Thread: <top>","main",":program","next","Primes","accept","AcceptFilter"];
var sourceNames = ["<none>","/Users/deven/Projects/Core_Java/HundredDaysOfCode/src/main/resources/primes.js"];
var sampleKeys = [[0,0,0],[1,0,0],[2,1,1],[3,1,31],[4,1,25],[5,1,13],[6,1,1]];
var profileData = [{"rs":[1],"c":0,"rx":0,"h":70,"i":0,"k":0,"l":8,"rc":0,"s":[1],"rh":70,"ri":0,"x":0,"id":0},{"rs":[2],"c":0,"rx":0,"h":70,"i":0,"k":1,"l":8,"p":0,"rc":0,"s":[2],"rh":70,"ri":0,"x":0,"id":1,"rp":0},{"rs":[3,4],"c":0,"rx":0,"h":70,"i":3,"k":2,"l":1,"p":1,"rc":0,"s":[3,4],"rh":70,"ri":3,"x":0,"id":2,"rp":1},{"rs":[5],"c":0,"rx":3,"h":66,"i":0,"k":3,"l":1,"p":2,"rc":0,"s":[5],"rh":66,"ri":0,"x":3,"id":3,"rp":2},{"rs":[7],"c":0,"rx":69,"h":1,"i":0,"k":4,"l":1,"p":2,"rc":0,"s":[6],"rh":1,"ri":0,"x":69,"id":4,"rp":2},{"c":57,"rx":3,"h":66,"i":9,"k":5,"l":1,"p":3,"rc":57,"rh":66,"ri":9,"x":3,"id":5,"rp":3},{"p":4,"c":0,"s":[7],"h":1,"x":69,"i":0,"k":4,"id":6,"l":1,"ro":4},{"c":0,"rx":69,"h":1,"i":0,"k":6,"l":1,"p":6,"rc":0,"s":[8],"rh":1,"ri":1,"x":69,"id":7,"rp":4},{"p":7,"c":0,"h":1,"x":69,"i":1,"k":6,"id":8,"l":1,"ro":7}];
var colorData = [{"0":"rgb(219, 179, 64)","1":"rgb(215, 107, 66)","2":"rgb(226, 138, 38)","3":"rgb(224, 140, 53)","4":"rgb(203, 148, 53)","5":"rgb(208, 141, 70)","6":"rgb(213, 120, 45)"},{"2":"rgb(95, 207, 207)","3":"rgb(62, 176, 176)","4":"rgb(82, 195, 195)","5":"rgb(92, 203, 203)","6":"rgb(77, 189, 189)"},{},{},{},{},{},{},{"0":"rgb(190, 190, 190)","1":"rgb(186, 186, 186)"}];
var languageNames = ["","js","","","","","","","<none>"];
function resize() {
owner_resize(document.firstElementChild.clientWidth);
fg_resize(document.firstElementChild.clientWidth);
h_resize(document.firstElementChild.clientWidth);
}
window.onresize = resize;
function init(evt) {
fg_init(evt)
h_init(evt)
resize();
}
var searchColor = "rgb(255, 0, 255)";
/*
 * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

var searchbtn, matchedtxt;
// ctrl-F for search
graph_register_handler("f", "Search or clear highlighted entries", search_prompt);

function search_prompt() {
    if (search_matches.length == 0) {
        var term = prompt("Enter a search term (regexp " +
                                                 "allowed, eg: ^ext4_)", "");
        if (term != null) {
            search(term);
        }
    } else {
        reset_search();
        searchbtn.style["opacity"] = "0.8";
        searchbtn.firstChild.nodeValue = "Search"
        matchedtxt.style["opacity"] = "0.0";
        matchedtxt.firstChild.nodeValue = ""
    }
}
function search(term) {
fg_search(term)
h_search(term)
}
    function reset_search() {
fg_reset_search()
h_reset_search()
}
/*
 * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

// Cycle through grpah coloring.

var color_type = "fg";
let legend_state = false;

function color_cycle() {
    let legend_visible = legend_state
    if (legend_visible) {
        color_legend(); // Hide the old legend.
    }
    if (color_type == "fg") {
        color_type = "bl";
    } else if (color_type == "bl") {
        color_type = "bc";
    } else {
        color_type = "fg";
    }
    update_color(color_type);
    if (legend_visible) {
        color_legend(); // Show the old legend.
    }
}

function update_color(color_type) {
    fg_update_color(color_type);
    h_update_color(color_type);
}

function color_for_key(language_index, key) {
    return colorData[language_index][key];
}

function color_for_compilation(interpreted, compiled) {
    if (interpreted + compiled == 0) {
        let gray = 192.0
        return "rgb(" + gray.toFixed() + ", " + gray.toFixed() + ", " + gray.toFixed() + ")";
    }
    let total = compiled + interpreted;
    let h = total == 0 ? 0.0 : (2.0 / 3.0) * (interpreted / total);
    let h6 = h * 6;
    let s = 0.8;
    let v = 0.8;
    let c = s * v;
    let x = c * (1 - Math.abs((h6) % 2 - 1));
    let m = v - c;
    let rprime;
    let gprime;
    let bprime;

    if (h6 < 1) {
        rprime = c;
        gprime = x;
        bprime = 0;
    } else if (h6 < 2) {
        rprime = x;
        gprime = c;
        bprime = 0;
    } else if (h6 < 3) {
        rprime = 0;
        gprime = c;
        bprime = x;
    } else if (h6 < 4) {
        rprime = 0;
        gprime = x;
        bprime = c;
    } else if (h6 < 5) {
        rprime = x;
        gprime = 0;
        bprime = c;
    } else {
        rprime = c;
        gprime = 0;
        bprime = x;
    }

    let r = ((rprime + m) * 255);
    let g = ((gprime + m) * 255);
    let b = ((bprime + m) * 255);
    return "rgb(" + r.toFixed() + ", " + g.toFixed() + ", " + b.toFixed() + ")";
}

function color_create_legend() {
    let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    let e = document.createElementNS("http://www.w3.org/2000/svg", "g");
    e.id = "legend_" + color_type;

    let r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    svg.x.baseVal.value = xpad;
    svg.y.baseVal.value = 50;
    r.className.baseVal = "popup";
    r.x.baseVal.value = 0;
    r.y.baseVal.value = 0;
    r.width.baseVal.value = 250;
    r.style.fill = "white";
    r.style.stroke = "black";
    r.style["stroke-width"] = 2;
    r.rx.baseVal.value = 2;
    r.ry.baseVal.vlaue = 2;

    let t = document.createElementNS("http://www.w3.org/2000/svg", "text");
    t.className.baseVal = "title";
    t.style.textAnchor = "middle";
    t.setAttribute("x", 125);
    t.setAttribute("y", fg_frameheight * 2);
    t.style.fontSize = fontSize * 1.5;
    t.style.fontFamily = "Verdana";
    t.style.fill = "rgb(0, 0, 0)";
    t.textContent = "Legend & Help";

    e.appendChild(r);
    e.appendChild(t);
    e.style.display = "none";
    svg.appendChild(e);

    let entry_count = 0;
    if (color_type == "fg") {
        let color_name = Object.getOwnPropertyNames(colorData[0])[0];
        let color = colorData[0][color_name];
        color_legend_entry(e, entry_count, color, "Sample colors are unique to functions");

        entry_count++;
    } else if (color_type == "bl") {
        for (let i = 0; i < languageNames.length; i++) {
            if (languageNames[i] != "") {
                let color_name = Object.getOwnPropertyNames(colorData[i])[0];
                let color = colorData[i][color_name];
                color_legend_entry(e, entry_count, color, languageNames[i]);

                entry_count++;
            }
        }
    } else if (color_type == "bc") {
        color_legend_entry(e, 0, color_for_compilation(0, 0), "No self samples");
        for (let i = 0; i <= 4; i++) {
            let color = color_for_compilation(4 - i, i);
            let text = (i * 25) + "% samples were compiled.";

            color_legend_entry(e, i + 1, color, text);
        }

        entry_count = 6;
    }

    let help_entry_count = 0;

    for (; help_entry_count < help_strings.length; help_entry_count++) {
        graph_help_entry(e, entry_count + help_entry_count + 1, help_strings[help_entry_count][0], help_strings[help_entry_count][1]);
    }

    if (help_entry_count > 0) {
        entry_count = entry_count + help_entry_count + 1;
    }
    r.height.baseVal.value = (fg_frameheight * 2.5) + (entry_count + 1) * fg_frameheight * 1.5;
    color_insert_legend(svg);
    return e;
}

function color_insert_legend(e) {
    let help = document.getElementById("help");
    if (help == null) {
        document.firstElementChild.appendChild(e);
    } else {
        document.firstElementChild.insertBefore(e, help.parentElement);
    }
}

function color_legend_entry(e, i, color, text) {
    let y = (fg_frameheight * 2.3) + (i + 1) * fg_frameheight * 1.5;

    let box = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    box.x.baseVal.value = xpad;
    box.y.baseVal.value = y;
    box.width.baseVal.value = fg_frameheight * 2;
    box.height.baseVal.value = fg_frameheight;
    box.style.fill = color;
    box.style.stroke = "black";
    box.style["stroke-width"] = 0.5;
    box.rx.baseVal.value = 2;
    box.ry.baseVal.vlaue = 2;

    let label = document.createElementNS("http://www.w3.org/2000/svg", "text");
    label.className.baseVal = "label";
    label.style.textAnchor = "left";
    label.setAttribute("x", xpad + fg_frameheight * 3);
    label.setAttribute("y", y - 5 + fg_frameheight);
    label.style.fontSize = fontSize;
    label.style.fontFamily = "Verdana";
    label.style.fill = "rgb(0, 0, 0)";
    label.textContent = text;

    e.appendChild(box);
    e.appendChild(label);
}

function color_legend() {
    let legend_id = "legend_" + color_type;
    let e = document.getElementById(legend_id);
    if (e == null) {
        e = color_create_legend();
    }
    if (e != null) {
        if (e.style["display"] == "none") {
            e.style["display"] = "block";
            graph_popup_fix_width(e, false);
        } else {
            e.style["display"] = "none";
        }
    }
    legend_state = !legend_state;
    graph_ensure_space();
}

// C for color cycle.
graph_register_handler("c", "Cycle through graph colorings", color_cycle);
graph_register_handler("?", "Toggle legend & help display", color_legend);
var xpad = 10.0;
var fg_width = 1200;
var fg_bottom_padding = 34.0;
var fg_min_width = 3.0;
var fg_frameheight = 16.0;
var fg_top_padding = 36.0;/*
 * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

var flamegraph, flamegraph_details, search_matches, fg_xmin, fg_xmax, fg_zoomed_sample, fg_max_depth, fg_svg, fg_collapsed;
function fg_init(evt) {
    flamegraph_details = document.getElementById("details").firstChild;
    searchbtn = document.getElementById("search");
    matchedtxt = document.getElementById("matched");
    flamegraph = document.getElementById("flamegraph");
    search_matches = [];
    fg_collapsed = true;
    fg_xmin = 0;
    fg_xmax = profileData[0].h;
    fg_zoomed_sample = profileData[0];
    var el = flamegraph.getElementsByTagName("g");
    for(let i=0;i<el.length;i++)
        update_text(el[i]);
}

function fg_element_for_sample(sample) {
    if (sample.hasOwnProperty("fg_element")) {
        return sample.fg_element;
    } else {
        let e = document.getElementById("f_" + sample.id);
        sample.fg_element = e;
        return e;
    }
}

function fg_create_element_for_sample(sample, width, x) {
    let y = fg_y_for_sample(sample);
    let e = document.createElementNS("http://www.w3.org/2000/svg", "g");
    e.className.baseVal = "func_g";
    e.onmouseover = function(e) {s(this)};
    e.onmouseout = function(e) {c(this)};
    e.onclick = function(e) {zoom(this)};
    e.id =  "f_" + sample.id;

    let title = document.createElementNS("http://www.w3.org/2000/svg", "title");
    title.textContent = "Blah";

    let r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    r.x.baseVal.value = x;
    r.y.baseVal.value = y;
    r.width.baseVal.value = width;
    r.height.baseVal.value = fg_frameheight
    if (sample.searchMatch) {
        r.style.fill =  searchColor;
    } else {
        r.style.fill = fg_color_for_sample(color_type, sample);
    }
    r.rx.baseVal.value = 2;
    r.ry.baseVal.vlaue = 2;

    let t = document.createElementNS("http://www.w3.org/2000/svg", "text");
    t.style.textAnchor = "left";
    t.setAttribute("x", x + 3);
    t.setAttribute("y", y - 5 + fg_frameheight);
    t.style.fontSize = fontSize;
    t.style.fontFamily = "Verdana";
    t.style.fill = "rgb(0, 0, 0)";

    e.appendChild(title);
    e.appendChild(r);
    e.appendChild(t);
    flamegraph.appendChild(e);
    sample.fg_element = e;
    return e;
}

function fg_toggle_collapse() {
    // Hide all the existing elements
    let iter = fg_sample_and_children_depth_first(profileData[0]);
    let c = iter.next();
    while (!c.done) {
        let e = fg_element_for_sample(c.value);
        if (e != null) {
            e.style["display"] = "none";
        }
        c = iter.next();
    }
    // Find the correct element to zoom to
    let sample_to_zoom_to = fg_zoomed_sample;
    if (!fg_collapsed && fg_zoomed_sample.hasOwnProperty("ro")) {
        sample_to_zoom_to = profileData[fg_zoomed_sample.ro];
    }

    // Toggle fg_collapsed
    fg_collapsed = !fg_collapsed;

    // Zoom to the correct element
    if (sample_to_zoom_to == profileData[0]) {
        unzoom();
    } else {
        zoom(fg_element_for_sample(sample_to_zoom_to));
    }
    fg_update_color(color_type)
}

function fg_x_for_sample(sample) {
    if (fg_collapsed) {
        return (sample.rx - fg_xmin) / (fg_xmax - fg_xmin) * (fg_width - 2 * xpad) + xpad;
    } else {
        return (sample.x - fg_xmin) / (fg_xmax - fg_xmin) * (fg_width - 2 * xpad) + xpad;
    }
}

function fg_y_for_sample(sample) {
    if (fg_collapsed) {
        return (collapsed_depth_for_sample(sample) + 1) * -fg_frameheight - fg_bottom_padding;
    } else {
        return (depth_for_sample(sample) + 1) * -fg_frameheight - fg_bottom_padding;
    }
}

function fg_sample_and_children_depth_first(sample) {
    if (fg_collapsed) {
        return collapsed_sample_and_children_depth_first(sample);
    } else {
        return sample_and_children_depth_first(sample);
    }
}

function fg_width_for_sample(sample) {
    if (fg_collapsed) {
        return sample.rh / (fg_xmax - fg_xmin) * (fg_width - 2 * xpad);
    } else {
        return sample.h / (fg_xmax - fg_xmin) * (fg_width - 2 * xpad);
    }
}

// zoom
function zoom_child(sample) {
    let width = fg_width_for_sample(sample);
    let x = fg_x_for_sample(sample);
    let y = fg_y_for_sample(sample);
    let e = fg_element_for_sample(sample);

    if (width < fg_min_width) {
        if (e != null) {
            e.style["display"] = "none";
        }
        return;
    } else {
        let depth = depth_for_sample(sample);
        if (depth > fg_max_depth) {
            fg_max_depth = depth;
        }
    }
    if (e == null) {
        e = fg_create_element_for_sample(sample, width, x);
    } else {
        e.style["display"] = "block";
        e.style["opacity"] = "1";
    }

    let title = e.firstElementChild;
    let r = e.children[1];
    let t = e.lastElementChild;
    let name = name_for_sample(sample);
    let source = source_for_sample(sample);
    let sourceLine = source_line_for_sample(sample);

    let compiled = 0;
    let interpreted = 0;
    let hits = 0;
    if (fg_collapsed) {
        compiled = sample.rc;
        interpreted = sample.ri;
        hits = sample.rh;
    } else {
        compiled = sample.c;
        interpreted = sample.i;
        hits = sample.h;
    }

    title.textContent = name + " (" + languageNames[sample.l] + ")\n" +
        "Self samples: " + (interpreted + compiled) + " (" + (100 * (compiled + interpreted) / (fg_xmax - fg_xmin)).toFixed(2) + "%)\n" +
        "Total samples: " + (hits) + " (" + (100 * (hits) / (fg_xmax - fg_xmin)).toFixed(2) + "%)\n" +
        "Source location: " + source + ":" + sourceLine + "\n";

    r.x.baseVal.value = x;
    r.y.baseVal.value = y;
    t.x.baseVal[0].value = x + 3;
    t.y.baseVal[0].value = y - 5 + fg_frameheight;

    r.width.baseVal.value = width;
    update_text_parts(e, r, t, width - 3, name);
}

function zoom_parent(sample) {
    let width =  fg_width - 2 * xpad;
    let x = xpad;
    let y = fg_y_for_sample(sample);
    let e = fg_element_for_sample(sample);
    if (e != null) {
        e.style["display"] = "block";
        e.style["opacity"] = "0.5";

        let title = e.firstElementChild;
        let r = e.children[1];
        let t = e.lastElementChild;

        title.textContent = "Function: " + name + "\n" +
            sample.h + " samples (" + sample.i + " interpreted, " + sample.c + " compiled).\n" +
            " Parent of displayed sample range.\n";

        r.x.baseVal.value = x;
        r.y.baseVal.value = y;
        t.x.baseVal[0].value = x + 3;
        t.y.baseVal[0].value = y - 5 + fg_frameheight;

        r.width.baseVal.value = width;

        update_text_parts(e, r, t, width - 3, name_for_sample(sample).replace(/\\([^(]*\\)$/,""));
    }
}

function zoom(node) {
    let data = sample_parents_and_unrelated_for_id(node.getAttribute("id").substring(2));
    let sample = data[0];
    let parents = data[1];
    let unrelated = data[2];
    fg_zoomed_sample = sample;
    if (fg_collapsed) {
        fg_xmin = sample.rx;
        fg_xmax = sample.rx + sample.rh;
    } else {
        fg_xmin = sample.x;
        fg_xmax = sample.x + sample.h;
    }
    fg_max_depth = 0;

    var unzoombtn = document.getElementById("unzoom");
    unzoombtn.style["opacity"] = "1.0";

    zoom_internal(sample, parents, unrelated);
}

function fg_canvas_resize() {
    let height = fg_frameheight * (fg_max_depth + 1) + fg_top_padding + fg_bottom_padding;
    let svg = document.firstElementChild;
    let fg_svg = flamegraph.parentElement;
    let old_height = fg_svg.height.baseVal.value;
    fg_svg.height.baseVal.value = height;
    let viewBox = fg_svg.viewBox.baseVal;
    viewBox.y = -height;
    viewBox.height = height;
    reposition_histogram(height);
    let fg_canvas = document.getElementById("fg_canvas");
    fg_canvas.height.baseVal.value = height;
    fg_canvas.y.baseVal.value = -height;
    graph_ensure_space();
}

function zoom_internal(sample, parents, unrelated) {
    for (const u of unrelated) {
        let iter = fg_sample_and_children_depth_first(u);
        let c = iter.next();
        while (!c.done) {
            let e = fg_element_for_sample(c.value);
            if (e != null) {
                e.style["display"] = "none";
            }
            c = iter.next();
        }
    }
    for (const p of parents) {
        zoom_parent(p);
    }
    let iter = fg_sample_and_children_depth_first(sample);
    let c = iter.next();
    while (!c.done) {
        zoom_child(c.value);
        c = iter.next();
    }
    fg_search_update(search_matches);
    fg_canvas_resize();
    rebuild_histogram(sample);
}

function unzoom() {
    var unzoombtn = document.getElementById("unzoom");
    unzoombtn.style["opacity"] = "0.1";

    fg_xmin = 0;
    fg_xmax = profileData[0].h
    fg_max_depth = 0;
    fg_zoomed_sample = profileData[0];

    zoom_internal(profileData[0], [], []);
}

// search
function fg_search(term) {
    var re = new RegExp(term);

    let search_matches = []

    let iter = sample_and_children_depth_first(profileData[0]);
    let c = iter.next();
    while (!c.done) {
        let sample = c.value;
        if (name_for_sample(sample).match(re)) {
            fg_highlight_sample(search_matches, sample);
        }
        c = iter.next();
    }

    fg_search_update(search_matches);

    if (search_matches.length == 0)
        return;

    searchbtn.style["opacity"] = "0.8";
    searchbtn.firstChild.nodeValue = "Reset Search"
}

function fg_highlight_sample(samples, sample) {
    sample.searchMatch = true;
    samples.push(sample);
    let e = fg_element_for_sample(sample);
    if (e != null) {
        let r = e.children[1];
        r.style.fill = searchColor;
    }
}

function fg_search_update(samples) {
    search_matches = samples.slice();

    if (samples.length == 0) {
        matchedtxt.style["opacity"] = "0.0";
        matchedtxt.firstChild.nodeValue = ""
        return;
    }

    samples.sort(function(a, b){
        if ((a.x - b.x) == 0) {
            if ((b.h - a.h) == 0) {
                return a.id - b.id;
            } else {
                return b.h - a.h;
            }
        } else {
            return a.x - b.x;
        }
    });

    let count = 0;
    let lastx = 0;
    let nextx = 0;

    for (const sample of samples) {
        // Skip over anything outside our zoom or up stack from the zoomed element.
        if (sample.x < fg_xmin || sample.x + sample.h > fg_xmax || sample.id < fg_zoomed_sample.id) {
            continue;
        }
        if (sample.x >= nextx) {
            lastx = sample.x;
            nextx = lastx + sample.h;
            count += nextx - lastx;
        }
    }


    // display matched percent
    matchedtxt.style["opacity"] = "1.0";
    let pct = 100 * count / (fg_xmax - fg_xmin);
    if (pct == 100) {
        pct = "100"
    } else {
        pct = pct.toFixed(1)
    }
    matchedtxt.firstChild.nodeValue = "Matched: " + pct + "%";
}

function fg_searchover(e) {
    searchbtn.style["opacity"] = "1.0";
}

function fg_searchout(e) {
    searchbtn.style["opacity"] = "0.8";
}

function fg_reset_search() {
    for (const match of search_matches) {
        match.searchMatch = false;
        let e = fg_element_for_sample(match);
        if (e != null) {
            let r = e.children[1];
            let color = match.currentColor;
            if (color == undefined) {
                color = fg_color_for_sample("fg", match);
            }
            r.style.fill = color;
        }
    }
    search_matches = [];
}

function fg_update_color(color_type) {
    let iter = fg_sample_and_children_depth_first(profileData[0]);
    let c = iter.next();
    while (!c.done) {
        let sample = c.value;
        let color = fg_color_for_sample(color_type, sample);
        sample.currentColor = color;
        if (sample.searchMatch != true) {
            let e = fg_element_for_sample(sample);
            if (e != null) {
                let r = e.children[1];
                r.style.fill = color;
            }
        }
        c = iter.next();
    }
}

function fg_color_for_sample(color_type, sample) {
    if (color_type == "fg") {
        return color_for_key(0, key_for_sample(sample));
    } else if (color_type == "bl") {
        return color_for_key(sample.l, key_for_sample(sample));
    } else if (color_type = "bc") {
        if (fg_collapsed) {
            return color_for_compilation(sample.ri, sample.rc);
        } else {
            return color_for_compilation(sample.i, sample.c);
        }
    }
}

function fg_resize(new_width) {
    fg_width = new_width
    let fg_svg = flamegraph.parentElement;
    fg_svg.width.baseVal.value = new_width;
    let viewbox = fg_svg.viewBox.baseVal;
    viewbox.width = new_width
    let fg_canvas = document.getElementById("fg_canvas");
    fg_canvas.width.baseVal.value = new_width;
    if (fg_zoomed_sample == profileData[0]) {
        unzoom();
    } else {
        zoom(fg_element_for_sample(fg_zoomed_sample));
    }
    document.getElementById("fg_title").setAttribute("x", new_width / 2);
    document.getElementById("fg_help").setAttribute("x", new_width / 2);
    document.getElementById("search").setAttribute("x", new_width - xpad);

}

graph_register_handler("r", "Toggle collapse of recursive calls", fg_toggle_collapse);
var h_width = 1200.0;
var h_minwidth = 3.0;
var h_top_padding = 36.0;
var h_bottom_padding = 34.0;
var h_frameheight = 16.0;
var histogramData = [{"c":57,"i":9,"id":5,"k":5,"l":1},{"c":0,"i":3,"id":2,"k":2,"l":1},{"c":0,"i":1,"id":7,"k":6,"l":1}];
/*
 * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

var histogram;
var h_max;
var h_max_depth;
var h_search_regex;

function h_init(evt) {
    histogram = document.getElementById("histogram");
    let bar = histogramData[0];
    h_max = bar.c + bar.i
    h_search_regex = null;
}

// search
function h_search(term) {
    h_search_regex = new RegExp(term);
    h_update_search();
}

function h_update_search() {
    let re = h_search_regex;
    if (re != null) {
        for (let i = 0; i < histogramData.length; i++) {
            let bar = histogramData[i];
            if (name_for_sample(bar).match(re)) {
                bar.searchMatch = true;
                let e = h_element_for_id(i);
                h_highlight_bar(i, bar);
            }
        }
    } else if (hilight_bar != null) {
        for (let i = 0; i < histogramData.length; i++) {
            let bar = histogramData[i];
            if (hilight_bar.k == bar.k) {
                bar.searchMatch = true;
                let e = h_element_for_id(i);
                h_highlight_bar(i, bar);
            }
        }
    }
}

var hilight_bar = null;

function h_reset_search() {
    for (let i = 0; i < histogramData.length; i++) {
        let bar = histogramData[i];
        if (bar.searchMatch = true) {
            bar.searchMatch = false;
            h_unhighlight_bar(i, bar);
        }
    }
    h_search_regex = null;
}

function h_highlight_bar(id, bar) {
    let e = h_element_for_id(id)
    if (e != null) {
        let r = e.children[1];
        r.style.fill = searchColor;
    }
}

function h_unhighlight_bar(id, bar) {
    let e = h_element_for_id(id)
    if (e != null) {
        let color = bar.currentColor;
        if (color == undefined) {
            color = h_color_for_sample(color_type, bar);
        }
        let r = e.children[1];
        r.style.fill = color;
    }
}

function h_highlight(e) {
    let id = e.getAttribute("id").substring(2);
    let bar = histogram_entry_for_id(id);
    if (hilight_bar != null && hilight_bar.k == bar.k) {
        hilight_element = null;
        reset_search();
    } else {
        reset_search();
        hilight_bar = bar;
        h_highlight_bar(id, bar);

        let iter = sample_and_children_depth_first(profileData[0]);
        let c = iter.next();
        while (!c.done) {
            let sample = c.value;
            if (sample.k == bar.k) {
                fg_highlight_sample(search_matches, sample);
            }
            c = iter.next();
        }
    }
}

function histogram_entry_for_id(id) {
    return histogramData[id];
}

function reposition_histogram(y) {
    let svg = histogram.parentNode;
    svg.setAttribute("y", y);
}

function h_element_for_id(id) {
    return document.getElementById("h_" + id);
}

function h_create_element_for_id(id, bar, width) {
    let y = h_top_padding + id * h_frameheight;
    let e = document.createElementNS("http://www.w3.org/2000/svg", "g");
    e.className.baseVal = "func_h";
    e.onmouseover = function(e) {s(this)};
    e.onmouseout = function(e) {c(this)};
    e.onclick = function(e) {h_highlight(this)};
    e.id =  "h_" + id;

    let title = document.createElementNS("http://www.w3.org/2000/svg", "title");
    title.textContent = "Blah";

    let r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    r.x.baseVal.value = xpad;
    r.y.baseVal.value = y;
    r.width.baseVal.value = width;
    r.height.baseVal.value = fg_frameheight

    r.style.fill = h_color_for_sample(color_type, bar);
    r.rx.baseVal.value = 2;
    r.ry.baseVal.vlaue = 2;

    let t = document.createElementNS("http://www.w3.org/2000/svg", "text");
    t.style.textAnchor = "left";
    t.setAttribute("x", xpad + 3);
    t.setAttribute("y", y - 5 + fg_frameheight);
    t.style.fontSize = fontSize;
    t.style.fontFamily = "Verdana";
    t.style.fill = "rgb(0, 0, 0)";

    e.appendChild(title);
    e.appendChild(r);
    e.appendChild(t);
    histogram.appendChild(e);
    return e;
}

function h_update_bar(id, bar) {
    let width = ((bar.c + bar.i) / h_max) * (h_width - 2 * xpad);
    let space_after = h_width - 2 * xpad - 3 - width; // Allows for space after the bar and not extending into the right margin.
    if (width >= h_minwidth && id < 100) {
        if ((id + 1) > h_max_depth) {
            h_max_depth = id + 1;
        }
        let e = h_element_for_id(id);
        if (e == undefined) {
            e = h_create_element_for_id(id, bar, width);
        }
        e.style.display = "block";
        let title = e.firstElementChild;
        let r = e.children[1];
        let t = e.lastElementChild;

        let name = name_for_sample(bar);
        let source = source_for_sample(bar);
        let sourceLine = source_line_for_sample(bar);
        let hits = bar.i + bar.c;

        title.textContent = name + " (" + languageNames[bar.l] + ")\n" +
            "Samples: " + (hits) + " (" + (100 * (hits) / (fg_xmax - fg_xmin)).toFixed(2) + "%)\n" +
            "Source location: " + source + ":" + sourceLine + "\n";

        r.width.baseVal.value = width;
        r.style.fill = h_color_for_sample(color_type, bar);
        t.textContent = name;
        let t_width = t.textLength.baseVal.value;
        if (t_width < width - 6) {
            // If the text fits in the bar, put it there.
            t.x.baseVal[0].value = xpad + 3;
        } else if (t_width < space_after)  {
            // If the text fits after the bar put it there
            t.x.baseVal[0].value = xpad + 3 + width;
        } else {
            let w;
            if (width > space_after) {
                t.x.baseVal[0].value = xpad + 3;
                w = width;
            } else {
                t.x.baseVal[0].value = xpad + 3 + width;
                w = space_after;
            }
            let x = search_text_width(w, t, name_for_sample(bar), get_txt_lengths(name_for_sample(bar)));

            if (x > 2) {
                t.textContent = name_for_sample(bar).substring(0,x - 2) + "..";
            } else {
                t.textContent = "";
            }
        }
    }
}

function rebuild_histogram(sample) {
    h_max_depth = 0;
    let histogram = document.getElementById("histogram");
    for (const child of document.getElementsByClassName("func_h")) {
        child.style.display = "none";
    }
    let bars = {};
    calculate_histogram_bars(bars, sample);
    let data = [];
    for (const bar in bars) {
        data.push(bars[bar])
    }
    data.sort((a, b) => ((b["i"] + b["c"]) - (a["i"] + a["c"])));

    h_max = data[0].c + data[0].i;
    for (let i = 0; i < data.length; i++) {
        let bar = data[i];
        h_update_bar(i, bar);
    }

    histogramData = data;

    h_update_search();
    h_canvas_resize();
}

function h_canvas_resize() {
    let height = h_max_depth * h_frameheight + h_top_padding + h_bottom_padding;
    let svg = document.firstElementChild;
    let h_svg = histogram.parentElement;
    let old_height = h_svg.height.baseVal.value;
    h_svg.height.baseVal.value = height;
    h_svg.viewBox.baseVal.height = height;
    let h_canvas = document.getElementById("h_canvas");
    h_canvas.height.baseVal.value = height;
    graph_ensure_space();
}

function calculate_histogram_bars(bars, sample) {
    let bar;
    if (!bars.hasOwnProperty(sample.k)) {
        bar = [];
        bar["id"] = sample["id"];
        bar["i"] = 0;
        bar["c"] = 0;
        bar["l"] = sample["l"];
        bar["k"] = sample["k"];
        bars[sample.k] = bar;
    } else {
        bar = bars[sample.k];
    }
    if (fg_collapsed) {
        bar["i"] = bar["i"] + sample["ri"];
        bar["c"] = bar["c"] + sample["rc"];
        for (const child of collapsed_children(sample)) {
            calculate_histogram_bars(bars, child);
        }
    } else {
        bar["i"] = bar["i"] + sample["i"];
        bar["c"] = bar["c"] + sample["c"];
        for (const child of direct_children(sample)) {
            calculate_histogram_bars(bars, child);
        }
    }
}

function h_update_color(color_type) {
    for (let i = 0; i < histogramData.length; i++) {
        let bar = histogramData[i];
        let color = h_color_for_sample(color_type, bar);
        bar.currentColor = color;
        if (bar.searchMatch != true) {
            let e = h_element_for_id(i);
            if (e != null) {
                let r = e.children[1];
                r.style.fill = color;
            }
        }
    }
}

function h_color_for_sample(color_type, sample) {
    if (color_type == "fg") {
        return color_for_key(0, key_for_sample(sample));
    } else if (color_type == "bl") {
        return color_for_key(sample.l, key_for_sample(sample));
    } else if (color_type = "bc") {
        return color_for_compilation(sample.i, sample.c);
    }
}

function h_resize(new_width) {
    h_width = new_width
    let h_svg = histogram.parentElement;
    h_svg.width.baseVal.value = new_width;
    let viewbox = h_svg.viewBox.baseVal;
    viewbox.width = new_width
    let h_canvas = document.getElementById("h_canvas");
    h_canvas.width.baseVal.value = new_width;
    rebuild_histogram(fg_zoomed_sample);
    document.getElementById("h_title").setAttribute("x", new_width / 2);
}
]]>
</script><svg viewBox="0.0 -150.000000 1200.000000 150.000000" x="0.0" y="0.0" wdith="1200.0" height="150.0" >
<g id="flamegraph" >
<rect x="0.000000" y="-150.000000" width="1200.000000" height="150.000000" fill="url(#background)"  id="fg_canvas"/>
<g class="func_g" onmouseover="s(this)" onmouseout="c(this)" onclick="unzoom()" id="f_0" >
<title>Thread: &lt;top&gt;
Self samples: 0 (0.00%)
total samples:  70 (100.00%)
Source location: &lt;none&gt;:0
</title><rect x="10.000000" y="-50.000000" width="1180.000000" height="16.000000" fill="rgb(219, 179, 64)" rx="2" ry="2"/>
<text text-anchor="left" x="13.000000" y="-39.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  >Thread: &lt;top&gt;</text>
</g>
<g class="func_g" onmouseover="s(this)" onmouseout="c(this)" onclick="zoom(this)" id="f_1" >
<title>main
Self samples: 0 (0.00%)
total samples:  70 (100.00%)
Source location: &lt;none&gt;:0
</title><rect x="10.000000" y="-66.000000" width="1180.000000" height="16.000000" fill="rgb(215, 107, 66)" rx="2" ry="2"/>
<text text-anchor="left" x="13.000000" y="-55.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  >main</text>
</g>
<g class="func_g" onmouseover="s(this)" onmouseout="c(this)" onclick="zoom(this)" id="f_2" >
<title>:program
Self samples: 3 (4.29%)
total samples:  70 (100.00%)
Source location: /Users/deven/Projects/Core_Java/HundredDaysOfCode/src/main/resources/primes.js:1
</title><rect x="10.000000" y="-82.000000" width="1180.000000" height="16.000000" fill="rgb(226, 138, 38)" rx="2" ry="2"/>
<text text-anchor="left" x="13.000000" y="-71.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  >:program</text>
</g>
<g class="func_g" onmouseover="s(this)" onmouseout="c(this)" onclick="zoom(this)" id="f_3" >
<title>next
Self samples: 0 (0.00%)
total samples:  66 (94.29%)
Source location: /Users/deven/Projects/Core_Java/HundredDaysOfCode/src/main/resources/primes.js:31
</title><rect x="60.571429" y="-98.000000" width="1112.571429" height="16.000000" fill="rgb(224, 140, 53)" rx="2" ry="2"/>
<text text-anchor="left" x="63.571429" y="-87.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  >next</text>
</g>
<g class="func_g" onmouseover="s(this)" onmouseout="c(this)" onclick="zoom(this)" id="f_4" >
<title>Primes
Self samples: 0 (0.00%)
total samples:  1 (1.43%)
Source location: /Users/deven/Projects/Core_Java/HundredDaysOfCode/src/main/resources/primes.js:25
</title><rect x="1173.142857" y="-98.000000" width="16.857143" height="16.000000" fill="rgb(203, 148, 53)" rx="2" ry="2"/>
<text text-anchor="left" x="1176.142857" y="-87.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  ></text>
</g>
<g class="func_g" onmouseover="s(this)" onmouseout="c(this)" onclick="zoom(this)" id="f_5" >
<title>accept
Self samples: 66 (94.29%)
total samples:  66 (94.29%)
Source location: /Users/deven/Projects/Core_Java/HundredDaysOfCode/src/main/resources/primes.js:13
</title><rect x="60.571429" y="-114.000000" width="1112.571429" height="16.000000" fill="rgb(208, 141, 70)" rx="2" ry="2"/>
<text text-anchor="left" x="63.571429" y="-103.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  >accept</text>
</g>
<g class="func_g" onmouseover="s(this)" onmouseout="c(this)" onclick="zoom(this)" id="f_7" >
<title>AcceptFilter
Self samples: 0 (0.00%)
total samples:  1 (1.43%)
Source location: /Users/deven/Projects/Core_Java/HundredDaysOfCode/src/main/resources/primes.js:1
</title><rect x="1173.142857" y="-114.000000" width="16.857143" height="16.000000" fill="rgb(213, 120, 45)" rx="2" ry="2"/>
<text text-anchor="left" x="1176.142857" y="-103.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  ></text>
</g>
<text text-anchor="" x="10.000000" y="-17.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)" id="details" > </text>
<text text-anchor="" x="1090.000000" y="-17.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)" id="matched" onclick="search_prompt()" > </text>
</g>
</svg>
<text text-anchor="middle" x="600.000000" y="24.000000" font-size="17.000000" font-family="Verdana" fill="rgb(0, 0, 0)" id="fg_title" >Flamegraph</text>
<text text-anchor="middle" x="600.000000" y="36.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)" id="fg_help" >Press "?" for legend and help.</text>
<text text-anchor="" x="10.000000" y="24.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)" id="unzoom" onclick="unzoom()" style="opacity:0.1;cursor:pointer" >Reset zoom</text>
<text text-anchor="end" x="1190.000000" y="24.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)" id="search"  onclick="search_prompt()" onmouseover="fg_searchover()" onmouseout="fg_searchout()" >Search</text>
<svg viewBox="0.0 0.0 1200.000000 118.000000" x="0.0" y="150.0" wdith="1200.0" height="118.0" >
<g id="histogram" >
<rect x="0.000000" y="0.000000" width="1200.000000" height="118.000000" fill="url(#background)"  id="h_canvas"/>
<text text-anchor="middle" x="600.000000" y="24.000000" font-size="17.000000" font-family="Verdana" fill="rgb(0, 0, 0)" id="h_title" >Histogram</text>
<g class="func_h" onmouseover="s(this)" onmouseout="c(this)" onclick="h_highlight(this)" id="h_0" >
<title>Function: accept
66 samples (9 interpreted, 57 compiled).
94.29% of displayed samples.
</title><rect x="10.000000" y="36.000000" width="1180.000000" height="16.000000" fill="rgb(208, 141, 70)" rx="2" ry="2"/>
<text text-anchor="left" x="13.000000" y="47.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  >accept</text>
</g>
<g class="func_h" onmouseover="s(this)" onmouseout="c(this)" onclick="h_highlight(this)" id="h_1" >
<title>Function: :program
3 samples (3 interpreted, 0 compiled).
4.29% of displayed samples.
</title><rect x="10.000000" y="52.000000" width="53.636364" height="16.000000" fill="rgb(226, 138, 38)" rx="2" ry="2"/>
<text text-anchor="left" x="66.636364" y="63.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  >:program</text>
</g>
<g class="func_h" onmouseover="s(this)" onmouseout="c(this)" onclick="h_highlight(this)" id="h_2" >
<title>Function: AcceptFilter
1 samples (1 interpreted, 0 compiled).
1.43% of displayed samples.
</title><rect x="10.000000" y="68.000000" width="17.878788" height="16.000000" fill="rgb(213, 120, 45)" rx="2" ry="2"/>
<text text-anchor="left" x="30.878788" y="79.000000" font-size="12.000000" font-family="Verdana" fill="rgb(0, 0, 0)"  >AcceptFilter</text>
</g>
</g>
</svg>
</svg>